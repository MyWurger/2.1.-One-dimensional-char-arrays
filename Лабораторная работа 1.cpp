/*******************************************************************************
 * Л А Б О Р А Т О Р Н А Я   Р А Б О Т А  №1  З А   2   С Е М Е С Т Р   С  +  +*
 *-----------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                   *
 * Project Name  : Символьные данные                                           *
 * File Name     : Вариант1.CPP                                                *
 * Programmer(s) : Викулов Д.Г.                                                *
 * Modifyed By   :                                                             *
 * Created       : 4/03/22                                                     *
 * Last Revision : 6/03/22                                                     *
 * Comment(s)    : Получает на вход из файла две строки. Сначала ищет символы  *
 *                 первой строки, которых нет во второй. Затем объединяет      *
 *                 символы двух строк в одну выходную, в которой символы       *
 *                 исходных строк чередуются через один.                       *
 *******************************************************************************/

#include <iostream>                        // стандартные потоки ввода/вывода
#include <fstream>                         // файловые потоки ввода/вывода
using namespace std;                       // используем пространство имён std
const int Maxlen = 100;                    // неизменяемая максимальная длина массива
const char* FNAME_RES = "Result_01.txt";   // имя файла результатов

/*******************************************************************/
/*                    Н А Б О Р    Т Е С Т О В                     */
/*******************************************************************/

//const char* FNAME = "VtorayaStringBolse.txt"; //путь к файлу через константный указатель
//const char* FNAME = "Pustoi.txt";
//const char* FNAME = "Faila_Net.txt";
//const char* FNAME = "StrokiOdinakovie.txt";
//const char* FNAME = "PervayaStringBolse.txt";
//const char* FNAME = "NetPervoyStroki.txt";
//const char* FNAME = "NetVtoroyStroki.txt";
//const char* FNAME = "ProbeluVpervoyStroke.txt";
const char* FNAME = "ProbeluVoVtoroyStroke.txt";

/*******************************************************************/
/*               О С Н О В Н А Я     П Р О Г Р А М М А             */
/*******************************************************************/

int main()
{
	system("color F0");             // делаем консоль светлой
	setlocale(LC_ALL, "Rus");       // подключаем русский язык
	system("cls");                  // чистим консоль перед выводом
	char fword[Maxlen];             // первая строка файла
	char sword[Maxlen];             // вторая строка файла
	char NewWord[200];              // Новая строка, полученная совмещение первых двух
	int firstbuffSymb[256] = {0};   // массив ASCII-кодов символов первой строки
	int secondbuffSymb[256] = {0};  // массив ASCII-кодов символов второй строки
	int fLen = 0;                   // реальная длина строки 1
	int sLen = 0;                   // реальная длина строки 2
	int i = 0;                      // счётчик по первой строке
	int j = 0;                      // счётчик по второй строке
	int k = 0;                      // счётчик по сформированной строке
	int schet = 0;                  // счётчик для формирования новой строки
	int CodeSymb = 0;               // ASCII-коды символов строки
	int tLen = 0;                   // реальная длина сформированной строки
	
	ifstream fin;                   // объявление объекта для потокового введения данных из файла
	fin.open(FNAME);                // связываем обЪект с файлом. Открываем для чтения
	ofstream fout("Result_01.txt"); //файл вывода входной параметр

	// ПОИСК ОШИБОК В ВВЕДЁННОМ ФАЙЛЕ
	if (!fin.is_open())                                              // файл не найден
	{
		cout << " Файл " << FNAME << " не найден\n";
		fout << " Файл " << FNAME << " не найден\n";
		fin.close();                                                 // закрыть файл
		fout.close();                                                // закрыть файл записи
		system("pause");
		return 1;                                                    // выход по ошибке
	} //if

	if (fin.peek() == EOF)                                           // файл пуст. peek() смотрит, но не извлекает
	{
		cout << " Файл " << FNAME << " пустой\n";
		fout << " Файл " << FNAME << " пустой\n";  
		fin.close();                                                 // закрыть файл
		fout.close();                                                // закрыть файл записи
		system("pause");
		return 2;                                                    // выход по ошибке
	} //if

	// Файл существует, можно из него ЧИТАТЬ

	cout << "\n\t\tЧтение элементов из файла " << FNAME << "\n\n";
	fin.getline(fword, Maxlen);                                      // ввели первую строку
	cout << " Первая строка = <" << fword<<">" << endl;               // эхо-печать первой строки
	                                                 
	fin.getline(sword, Maxlen);                                      // ввели вторую строку
	cout << " Вторая строка = <" << sword<<">"<< endl;                // эхо-печать второй строки
	                              
	fin.close();                                                     // закрыть файл

	// ПОИСК РЕАЛЬНОЙ ДЛИНЫ СТРОК ИЗ ФАЙЛА

	while (fword[fLen] != '\0')                                      // пока не встретили терминальный ноль
	{
		fLen = fLen + 1;                                             // увеличиваем переменную-длинну
	} // while
	cout << " Длина первой строки: " << fLen << endl; 

	while (sword[sLen] != '\0')                                      // для второй строки
	{
		sLen = sLen + 1;
	} // while
	cout << " Длина второй строки: " << sLen << endl;

	if (fLen == 0 || sLen == 0)                                      // В файле отсутствует любая из двух строк
	{
		cout << " В файле отсутствует строка! Исправьте файл и перезапустите программу. \n";
		fout << " В файле отсутствует строка! Исправьте файл и перезапустите программу. \n";
		fout.close();                                                // закрыли файл вывода
		return 3;                                                    // вышли с ошибкой
	}

	while (i < fLen)                                                 // пока не дошли до конца первой строки
	{
		CodeSymb = (int)fword[i];                                    // перевели символ в код ASCII
		firstbuffSymb[CodeSymb] = firstbuffSymb[CodeSymb] + 1;       // увеличили счётчик символов с этим ASCII-кодом
		i = i + 1;                                                   // увеличили счётчик - перешли к следующему элементу строки 
	} // while

    tLen = fLen + sLen;                                              // подсчитали длину новой строки
	i = 0;                                                           // обнулили счётчик после цикла
	CodeSymb = 0; 

	while (i < sLen)                                                 // пока не дошли до конца второй строки
	{
		CodeSymb = (int)sword[i];                                    // перевели символ в код ASCII
		secondbuffSymb[CodeSymb] = secondbuffSymb[CodeSymb] + 1;     // увеличили счётчик символов с этим ASCII-кодом
		i = i + 1;                                                   // увеличили счётчик - перешли к следующему элементу строки 
	} // while

    //ПРИСТУПАЕМ НЕПОСРЕДСТВЕННО К РЕШЕНИЮ ЗАДАНИЯ
	fout << "\tРЕЗУЛЬТАТ\n";
	fout << " Символы первой строки, которых нет во второй: \n";
	cout << "\n\t\tПервая задача: \n\n";
	cout << " Символы первой строки, которые не содержатся во второй: \n";
	for (j = 0; j <= 256; j++)                                       // идём по индексам массивов 
	{
		if ((firstbuffSymb[j]!=0) && (secondbuffSymb[j]==0))         // если в первом массиве счётчик не ноли и во втором ноль, то данного символа во втором массиве нет
		{
			cout << char(j) << endl;                                 // переводим ASCII-код обратно в символ
			fout << char(j) << endl;                                 // дублируем запись в файл
		} // if
	} // for
	

	cout << "\t\tВторая задача: \n\n";  
	fout << " Результат второй задачи: \n";
	i = 0;                                                           // обнуляем счётчик после цикла
	j = 0;                                                           // обнуляем счётчик после цикла                                                      
	if (fLen == sLen)                                                // длины первых двух строк равны
	{  
		while ((schet < tLen))                                       // пока не дошли до конци новой строки
		{

			NewWord[k] = fword[i];                                   // присвоили значение элемента первой строки
			i = i + 1;                                               // шагнули на 1 вперёд по первой строке
			k = k + 1;                                               // шагнули на следующий индекс новой строки
			NewWord[k] = sword[j];                                   // присвоили этому индексу значение элемента второй строки
			j = j + 1;                                               // шагнули на 1 вперёд по второй строке
			k = k + 1;                                               // шагнули на следующий индекс новой строки
			schet = schet + 2;                                       // каждый проход цикла добавляется в новую строку по два элемента
		} // while
	} // if
	
	else if (fLen > sLen)                                            // длина первой строки больше длины второй
	{
		while (schet < 2*sLen)                                       // 2*sLen, потому что символы двух строк чередуются, поэтому строчка будет кончаться в два раза дольше
		{
			NewWord[k] = fword[i];                                   // присвоили значение элемента первой строки
			k = k + 1;                                               // шагнули на следующий индекс новой строки
			i = i + 1;                                               // шагнули на 1 вперёд по первой строке
			NewWord[k] = sword[j];                                   // присвоили этому индексу значение элемента второй строки
			j = j + 1;                                               // шагнули на 1 вперёд по второй строке
			k = k + 1;                                               // шагнули на следующий индекс новой строки
			schet = schet + 2;                                       // каждый проход цикла добавляется в новую строку по два элемента
		} // while                                                   // sLen закончилась - вышли
		for (i = j; i < fLen; i++)                                   // распределяем оставшиеся элементы первой строки, начиная с места, где прервался while
		{
			NewWord[k] = fword[i];                                   // добавляем их пачкой
			k = k + 1;
		} // for
	} // esle if
	else                                                             //остался случай fLen < sLen
	{
		while (schet < 2 * fLen)                                     // 2*fLen, потому что символы двух строк чередуются, поэтому строчка будет кончаться в два раза дольше
		{
			NewWord[k] = fword[i];                                   // присвоили значение элемента первой строки
			k = k + 1;												 // шагнули на следующий индекс новой строки
			i = i + 1;                                               // шагнули на 1 вперёд по первой строке
			NewWord[k] = sword[j];								     // присвоили этому индексу значение элемента второй строки
			j = j + 1;                                               // шагнули на 1 вперёд по второй строке
			k = k + 1;                                               // шагнули на следующий индекс новой строки
			schet = schet + 2;                                       // каждый проход цикла добавляется в новую строку по два элемента
		} // while
		for (j = i; j < sLen; j++)                                   // распределяем оставшиеся элементы второй строки, начиная с места, где прервался while
		{
			NewWord[k] = sword[j];                                   // добавляем их пачкой
			k = k + 1;
		} // for
	} // else
	

	//Второй вариант реализации
	/*while (schet < tLen)
	{
		if (fword[i] != '\0')
		{
			NewWord[k] = fword[i];
			i++;
			k++;
			schet++;
		}

		if (sword[j] != '\0')
		{
			NewWord[k] = sword[j];
			j++;
			k++;
			schet++;
		}

	}*/
	
	
	i = 0;                                                           // обнуляем счётчик после циклов
	cout << " Новая строка: <";
	for (i = 0; i < tLen; i++)                                       // выводим новую строку поэлементно
	{
		cout << NewWord[i]; 
		fout << NewWord[i];                                          // записываем результат в файл
	}// for
	cout <<">"<< endl;
	
	fout.close();                                                    // закрываем файл для записи
	system("pause");
	return 0;
}// main